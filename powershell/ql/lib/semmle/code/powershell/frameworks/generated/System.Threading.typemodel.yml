# THIS FILE IS AN AUTO-GENERATED MODELS AS DATA FILE. DO NOT EDIT.
extensions:
  - addsTo:
      pack: microsoft/powershell-all
      extensible: typeModel
    data:
    - ["system.threading.mutex", "system.threading.abandonedmutexexception", "Member[mutex]"]
    - ["system.boolean", "system.threading.readerwriterlockslim", "Member[isupgradeablereadlockheld]"]
    - ["system.int32", "system.threading.barrier", "Member[participantcount]"]
    - ["system.security.accesscontrol.semaphoresecurity", "system.threading.semaphore", "Method[getaccesscontrol].ReturnValue"]
    - ["system.int32", "system.threading.barrier", "Member[participantsremaining]"]
    - ["system.int32", "system.threading.readerwriterlockslim", "Member[waitingreadcount]"]
    - ["system.boolean", "system.threading.thread", "Method[join].ReturnValue"]
    - ["system.boolean", "system.threading.spinlock", "Member[isheldbycurrentthread]"]
    - ["system.uint32", "system.threading.thread!", "Method[volatileread].ReturnValue"]
    - ["system.uintptr", "system.threading.interlocked!", "Method[exchange].ReturnValue"]
    - ["system.boolean", "system.threading.waithandle", "Method[waitone].ReturnValue"]
    - ["system.threading.threadstate", "system.threading.threadstate!", "Member[stopped]"]
    - ["system.boolean", "system.threading.spinwait!", "Method[spinuntil].ReturnValue"]
    - ["system.boolean", "system.threading.volatile!", "Method[read].ReturnValue"]
    - ["system.boolean", "system.threading.thread!", "Method[yield].ReturnValue"]
    - ["system.boolean", "system.threading.cancellationtokensource", "Member[iscancellationrequested]"]
    - ["system.int32", "system.threading.interlocked!", "Method[decrement].ReturnValue"]
    - ["system.localdatastoreslot", "system.threading.thread!", "Method[allocatenameddataslot].ReturnValue"]
    - ["system.int32", "system.threading.nativeoverlapped", "Member[offsethigh]"]
    - ["system.int32", "system.threading.readerwriterlockslim", "Member[waitingupgradecount]"]
    - ["system.single", "system.threading.interlocked!", "Method[exchange].ReturnValue"]
    - ["system.uint64", "system.threading.interlocked!", "Method[decrement].ReturnValue"]
    - ["system.sbyte", "system.threading.interlocked!", "Method[compareexchange].ReturnValue"]
    - ["system.int32", "system.threading.interlocked!", "Method[or].ReturnValue"]
    - ["system.uint64", "system.threading.interlocked!", "Method[or].ReturnValue"]
    - ["system.uint16", "system.threading.interlocked!", "Method[exchange].ReturnValue"]
    - ["system.uintptr", "system.threading.thread!", "Method[volatileread].ReturnValue"]
    - ["system.threading.apartmentstate", "system.threading.apartmentstate!", "Member[sta]"]
    - ["system.uint64", "system.threading.interlocked!", "Method[read].ReturnValue"]
    - ["system.boolean", "system.threading.semaphoreslim", "Method[wait].ReturnValue"]
    - ["t", "system.threading.threadlocal", "Member[value]"]
    - ["system.boolean", "system.threading.eventwaithandleacl!", "Method[tryopenexisting].ReturnValue"]
    - ["system.boolean", "system.threading.readerwriterlockslim", "Method[tryenterwritelock].ReturnValue"]
    - ["system.int32", "system.threading.readerwriterlockslim", "Member[waitingwritecount]"]
    - ["system.threading.preallocatedoverlapped", "system.threading.preallocatedoverlapped!", "Method[unsafecreate].ReturnValue"]
    - ["system.threading.overlapped", "system.threading.overlapped!", "Method[unpack].ReturnValue"]
    - ["system.threading.nativeoverlapped*", "system.threading.threadpoolboundhandle", "Method[unsafeallocatenativeoverlapped].ReturnValue"]
    - ["system.sbyte", "system.threading.volatile!", "Method[read].ReturnValue"]
    - ["system.uint64", "system.threading.volatile!", "Method[read].ReturnValue"]
    - ["system.security.accesscontrol.eventwaithandlesecurity", "system.threading.threadingaclextensions!", "Method[getaccesscontrol].ReturnValue"]
    - ["system.runtime.interopservices.safehandle", "system.threading.threadpoolboundhandle", "Member[handle]"]
    - ["system.threading.threadstate", "system.threading.threadstate!", "Member[stoprequested]"]
    - ["system.single", "system.threading.thread!", "Method[volatileread].ReturnValue"]
    - ["system.uint16", "system.threading.volatile!", "Method[read].ReturnValue"]
    - ["system.int64", "system.threading.threadpool!", "Member[completedworkitemcount]"]
    - ["system.string", "system.threading.thread", "Member[name]"]
    - ["system.threading.cancellationtokenregistration", "system.threading.cancellationtoken", "Method[register].ReturnValue"]
    - ["system.boolean", "system.threading.countdownevent", "Method[signal].ReturnValue"]
    - ["system.intptr", "system.threading.nativeoverlapped", "Member[eventhandle]"]
    - ["system.uint32", "system.threading.interlocked!", "Method[compareexchange].ReturnValue"]
    - ["system.double", "system.threading.volatile!", "Method[read].ReturnValue"]
    - ["system.int16", "system.threading.volatile!", "Method[read].ReturnValue"]
    - ["t", "system.threading.asynclocalvaluechangedargs", "Member[currentvalue]"]
    - ["system.localdatastoreslot", "system.threading.thread!", "Method[allocatedataslot].ReturnValue"]
    - ["system.threading.compressedstack", "system.threading.compressedstack", "Method[createcopy].ReturnValue"]
    - ["system.security.accesscontrol.semaphoresecurity", "system.threading.threadingaclextensions!", "Method[getaccesscontrol].ReturnValue"]
    - ["system.boolean", "system.threading.itimer", "Method[change].ReturnValue"]
    - ["system.single", "system.threading.interlocked!", "Method[compareexchange].ReturnValue"]
    - ["system.threading.cancellationtokensource", "system.threading.cancellationtokensource!", "Method[createlinkedtokensource].ReturnValue"]
    - ["t", "system.threading.interlocked!", "Method[compareexchange].ReturnValue"]
    - ["system.object", "system.threading.thread!", "Method[volatileread].ReturnValue"]
    - ["system.intptr", "system.threading.waithandle!", "Member[invalidhandle]"]
    - ["system.intptr", "system.threading.nativeoverlapped", "Member[internalhigh]"]
    - ["microsoft.win32.safehandles.safewaithandle", "system.threading.waithandleextensions!", "Method[getsafewaithandle].ReturnValue"]
    - ["system.int32", "system.threading.semaphoreslim", "Member[currentcount]"]
    - ["system.collections.generic.ilist", "system.threading.threadlocal", "Member[values]"]
    - ["system.security.accesscontrol.mutexsecurity", "system.threading.threadingaclextensions!", "Method[getaccesscontrol].ReturnValue"]
    - ["system.threading.registeredwaithandle", "system.threading.threadpool!", "Method[unsaferegisterwaitforsingleobject].ReturnValue"]
    - ["system.boolean", "system.threading.cancellationtoken", "Member[canbecanceled]"]
    - ["system.int32", "system.threading.waithandle!", "Method[waitany].ReturnValue"]
    - ["system.threading.lockrecursionpolicy", "system.threading.lockrecursionpolicy!", "Member[norecursion]"]
    - ["system.boolean", "system.threading.executioncontext!", "Method[isflowsuppressed].ReturnValue"]
    - ["system.threading.tasks.task", "system.threading.cancellationtokensource", "Method[cancelasync].ReturnValue"]
    - ["system.boolean", "system.threading.eventwaithandle", "Method[set].ReturnValue"]
    - ["system.boolean", "system.threading.mutexacl!", "Method[tryopenexisting].ReturnValue"]
    - ["system.boolean", "system.threading.readerwriterlockslim", "Method[tryenterreadlock].ReturnValue"]
    - ["system.boolean", "system.threading.thread", "Method[trysetapartmentstate].ReturnValue"]
    - ["system.threading.mutex", "system.threading.mutexacl!", "Method[openexisting].ReturnValue"]
    - ["system.boolean", "system.threading.threadpool!", "Method[bindhandle].ReturnValue"]
    - ["system.threading.waithandle", "system.threading.countdownevent", "Member[waithandle]"]
    - ["system.threading.lazythreadsafetymode", "system.threading.lazythreadsafetymode!", "Member[executionandpublication]"]
    - ["system.uint32", "system.threading.interlocked!", "Method[exchange].ReturnValue"]
    - ["system.threading.apartmentstate", "system.threading.thread", "Member[apartmentstate]"]
    - ["system.int32", "system.threading.nativeoverlapped", "Member[offsetlow]"]
    - ["system.threading.waithandle", "system.threading.manualreseteventslim", "Member[waithandle]"]
    - ["system.boolean", "system.threading.manualresetevent", "Method[set].ReturnValue"]
    - ["system.threading.nativeoverlapped*", "system.threading.threadpoolboundhandle", "Method[allocatenativeoverlapped].ReturnValue"]
    - ["system.int32", "system.threading.semaphore", "Method[release].ReturnValue"]
    - ["system.threading.threadstate", "system.threading.thread", "Member[threadstate]"]
    - ["system.threading.lazythreadsafetymode", "system.threading.lazythreadsafetymode!", "Member[none]"]
    - ["system.int64", "system.threading.interlocked!", "Method[increment].ReturnValue"]
    - ["system.int64", "system.threading.barrier", "Method[addparticipant].ReturnValue"]
    - ["system.int32", "system.threading.countdownevent", "Member[initialcount]"]
    - ["system.boolean", "system.threading.manualreseteventslim", "Member[isset]"]
    - ["system.uint64", "system.threading.interlocked!", "Method[add].ReturnValue"]
    - ["system.int32", "system.threading.cancellationtoken", "Method[gethashcode].ReturnValue"]
    - ["system.boolean", "system.threading.countdownevent", "Method[tryaddcount].ReturnValue"]
    - ["system.boolean", "system.threading.readerwriterlock", "Member[isreaderlockheld]"]
    - ["system.object", "system.threading.thread!", "Method[getdata].ReturnValue"]
    - ["system.threading.waithandle", "system.threading.semaphoreslim", "Member[availablewaithandle]"]
    - ["system.threading.threadstate", "system.threading.threadstate!", "Member[aborted]"]
    - ["system.int32", "system.threading.countdownevent", "Member[currentcount]"]
    - ["system.byte", "system.threading.thread!", "Method[volatileread].ReturnValue"]
    - ["system.boolean", "system.threading.threadpool!", "Method[unsafequeuenativeoverlapped].ReturnValue"]
    - ["system.int32", "system.threading.timeout!", "Member[infinite]"]
    - ["system.threading.threadstate", "system.threading.threadstate!", "Member[abortrequested]"]
    - ["system.int64", "system.threading.interlocked!", "Method[or].ReturnValue"]
    - ["system.threading.compressedstack", "system.threading.thread", "Method[getcompressedstack].ReturnValue"]
    - ["system.boolean", "system.threading.threadpool!", "Method[setminthreads].ReturnValue"]
    - ["system.int64", "system.threading.interlocked!", "Method[add].ReturnValue"]
    - ["system.threading.synchronizationcontext", "system.threading.synchronizationcontext", "Method[createcopy].ReturnValue"]
    - ["system.double", "system.threading.interlocked!", "Method[compareexchange].ReturnValue"]
    - ["system.byte", "system.threading.interlocked!", "Method[exchange].ReturnValue"]
    - ["system.threading.eventwaithandle", "system.threading.eventwaithandleacl!", "Method[openexisting].ReturnValue"]
    - ["system.byte", "system.threading.volatile!", "Method[read].ReturnValue"]
    - ["system.boolean", "system.threading.monitor!", "Method[tryenter].ReturnValue"]
    - ["system.exception", "system.threading.threadexceptioneventargs", "Member[exception]"]
    - ["system.int32", "system.threading.readerwriterlockslim", "Member[recursiveupgradecount]"]
    - ["system.threading.threadstate", "system.threading.threadstate!", "Member[suspended]"]
    - ["system.intptr", "system.threading.interlocked!", "Method[compareexchange].ReturnValue"]
    - ["system.boolean", "system.threading.threadlocal", "Member[isvaluecreated]"]
    - ["system.object", "system.threading.threadabortexception", "Member[exceptionstate]"]
    - ["system.int32", "system.threading.volatile!", "Method[read].ReturnValue"]
    - ["system.boolean", "system.threading.countdownevent", "Member[isset]"]
    - ["system.uint32", "system.threading.volatile!", "Method[read].ReturnValue"]
    - ["system.boolean", "system.threading.readerwriterlock", "Member[iswriterlockheld]"]
    - ["system.boolean", "system.threading.threadpool!", "Method[unsafequeueuserworkitem].ReturnValue"]
    - ["system.security.accesscontrol.eventwaithandlesecurity", "system.threading.eventwaithandle", "Method[getaccesscontrol].ReturnValue"]
    - ["system.boolean", "system.threading.thread", "Member[isthreadpoolthread]"]
    - ["system.boolean", "system.threading.monitor!", "Method[isentered].ReturnValue"]
    - ["system.threading.mutex", "system.threading.mutexacl!", "Method[create].ReturnValue"]
    - ["system.uintptr", "system.threading.interlocked!", "Method[compareexchange].ReturnValue"]
    - ["system.boolean", "system.threading.lockcookie!", "Method[op_equality].ReturnValue"]
    - ["system.threading.synchronizationcontext", "system.threading.synchronizationcontext!", "Member[current]"]
    - ["system.uint32", "system.threading.interlocked!", "Method[or].ReturnValue"]
    - ["system.int32", "system.threading.semaphoreslim", "Method[release].ReturnValue"]
    - ["system.timespan", "system.threading.timeout!", "Member[infinitetimespan]"]
    - ["system.threading.threadpoolboundhandle", "system.threading.threadpoolboundhandle!", "Method[bindhandle].ReturnValue"]
    - ["system.threading.apartmentstate", "system.threading.apartmentstate!", "Member[unknown]"]
    - ["system.object", "system.threading.interlocked!", "Method[compareexchange].ReturnValue"]
    - ["system.int32", "system.threading.synchronizationcontext", "Method[wait].ReturnValue"]
    - ["system.boolean", "system.threading.threadpool!", "Method[queueuserworkitem].ReturnValue"]
    - ["system.int32", "system.threading.cancellationtokenregistration", "Method[gethashcode].ReturnValue"]
    - ["system.int32", "system.threading.overlapped", "Member[offsetlow]"]
    - ["system.threading.eventresetmode", "system.threading.eventresetmode!", "Member[autoreset]"]
    - ["system.uint32", "system.threading.interlocked!", "Method[decrement].ReturnValue"]
    - ["system.int16", "system.threading.interlocked!", "Method[exchange].ReturnValue"]
    - ["system.boolean", "system.threading.semaphore!", "Method[tryopenexisting].ReturnValue"]
    - ["system.boolean", "system.threading.spinlock", "Member[isheld]"]
    - ["system.byte", "system.threading.interlocked!", "Method[compareexchange].ReturnValue"]
    - ["system.boolean", "system.threading.autoresetevent", "Method[set].ReturnValue"]
    - ["system.boolean", "system.threading.monitor!", "Method[wait].ReturnValue"]
    - ["system.threading.eventresetmode", "system.threading.eventresetmode!", "Member[manualreset]"]
    - ["system.threading.eventwaithandle", "system.threading.eventwaithandle!", "Method[openexisting].ReturnValue"]
    - ["system.boolean", "system.threading.registeredwaithandle", "Method[unregister].ReturnValue"]
    - ["system.int32", "system.threading.abandonedmutexexception", "Member[mutexindex]"]
    - ["system.int32", "system.threading.manualreseteventslim", "Member[spincount]"]
    - ["system.threading.lockcookie", "system.threading.readerwriterlock", "Method[upgradetowriterlock].ReturnValue"]
    - ["system.int16", "system.threading.thread!", "Method[volatileread].ReturnValue"]
    - ["system.int32", "system.threading.thread", "Method[gethashcode].ReturnValue"]
    - ["system.boolean", "system.threading.countdownevent", "Method[wait].ReturnValue"]
    - ["system.threading.tasks.valuetask", "system.threading.periodictimer", "Method[waitfornexttickasync].ReturnValue"]
    - ["system.int32", "system.threading.readerwriterlock", "Member[writerseqnum]"]
    - ["system.boolean", "system.threading.thread", "Member[isalive]"]
    - ["system.threading.threadpriority", "system.threading.threadpriority!", "Member[abovenormal]"]
    - ["system.threading.asyncflowcontrol", "system.threading.executioncontext!", "Method[suppressflow].ReturnValue"]
    - ["system.threading.mutex", "system.threading.mutex!", "Method[openexisting].ReturnValue"]
    - ["system.threading.waithandle", "system.threading.cancellationtoken", "Member[waithandle]"]
    - ["system.boolean", "system.threading.cancellationtokenregistration!", "Method[op_inequality].ReturnValue"]
    - ["system.boolean", "system.threading.readerwriterlockslim", "Member[isreadlockheld]"]
    - ["system.threading.semaphore", "system.threading.semaphoreacl!", "Method[openexisting].ReturnValue"]
    - ["system.uint32", "system.threading.interlocked!", "Method[and].ReturnValue"]
    - ["system.threading.threadstate", "system.threading.threadstate!", "Member[waitsleepjoin]"]
    - ["system.uint64", "system.threading.interlocked!", "Method[exchange].ReturnValue"]
    - ["system.sbyte", "system.threading.interlocked!", "Method[exchange].ReturnValue"]
    - ["system.object", "system.threading.interlocked!", "Method[exchange].ReturnValue"]
    - ["system.int32", "system.threading.interlocked!", "Method[and].ReturnValue"]
    - ["system.boolean", "system.threading.cancellationtoken", "Method[equals].ReturnValue"]
    - ["system.int32", "system.threading.overlapped", "Member[offsethigh]"]
    - ["system.int32", "system.threading.thread!", "Method[getdomainid].ReturnValue"]
    - ["system.threading.threadpriority", "system.threading.threadpriority!", "Member[lowest]"]
    - ["system.threading.lazythreadsafetymode", "system.threading.lazythreadsafetymode!", "Member[publicationonly]"]
    - ["system.threading.threadstate", "system.threading.threadstate!", "Member[suspendrequested]"]
    - ["system.boolean", "system.threading.spinwait", "Member[nextspinwillyield]"]
    - ["system.localdatastoreslot", "system.threading.thread!", "Method[getnameddataslot].ReturnValue"]
    - ["system.boolean", "system.threading.cancellationtokensource", "Method[tryreset].ReturnValue"]
    - ["system.sbyte", "system.threading.thread!", "Method[volatileread].ReturnValue"]
    - ["system.double", "system.threading.thread!", "Method[volatileread].ReturnValue"]
    - ["system.runtime.remoting.contexts.context", "system.threading.thread!", "Member[currentcontext]"]
    - ["system.security.accesscontrol.mutexsecurity", "system.threading.mutex", "Method[getaccesscontrol].ReturnValue"]
    - ["system.boolean", "system.threading.lockcookie", "Method[equals].ReturnValue"]
    - ["system.threading.threadpriority", "system.threading.threadpriority!", "Member[highest]"]
    - ["system.boolean", "system.threading.mutex!", "Method[tryopenexisting].ReturnValue"]
    - ["microsoft.win32.safehandles.safewaithandle", "system.threading.waithandle", "Member[safewaithandle]"]
    - ["system.threading.cancellationtoken", "system.threading.cancellationtoken!", "Member[none]"]
    - ["system.boolean", "system.threading.waithandle!", "Method[signalandwait].ReturnValue"]
    - ["system.int64", "system.threading.barrier", "Method[addparticipants].ReturnValue"]
    - ["system.int32", "system.threading.interlocked!", "Method[compareexchange].ReturnValue"]
    - ["system.boolean", "system.threading.cancellationtokenregistration", "Method[equals].ReturnValue"]
    - ["system.boolean", "system.threading.barrier", "Method[signalandwait].ReturnValue"]
    - ["system.intptr", "system.threading.thread!", "Method[volatileread].ReturnValue"]
    - ["system.boolean", "system.threading.cancellationtokenregistration!", "Method[op_equality].ReturnValue"]
    - ["system.int32", "system.threading.synchronizationcontext!", "Method[waithelper].ReturnValue"]
    - ["system.boolean", "system.threading.manualreseteventslim", "Method[wait].ReturnValue"]
    - ["system.int64", "system.threading.timer!", "Member[activecount]"]
    - ["system.boolean", "system.threading.asyncflowcontrol!", "Method[op_inequality].ReturnValue"]
    - ["system.threading.hostexecutioncontext", "system.threading.hostexecutioncontextmanager", "Method[capture].ReturnValue"]
    - ["system.boolean", "system.threading.namedwaithandleoptions", "Member[currentsessiononly]"]
    - ["system.threading.semaphore", "system.threading.semaphore!", "Method[openexisting].ReturnValue"]
    - ["system.int16", "system.threading.interlocked!", "Method[compareexchange].ReturnValue"]
    - ["system.appdomain", "system.threading.thread!", "Method[getdomain].ReturnValue"]
    - ["system.int64", "system.threading.monitor!", "Member[lockcontentioncount]"]
    - ["system.int32", "system.threading.readerwriterlockslim", "Member[recursivereadcount]"]
    - ["system.int32", "system.threading.thread", "Member[managedthreadid]"]
    - ["t", "system.threading.volatile!", "Method[read].ReturnValue"]
    - ["system.int32", "system.threading.readerwriterlockslim", "Member[currentreadcount]"]
    - ["system.uint64", "system.threading.thread!", "Method[volatileread].ReturnValue"]
    - ["system.boolean", "system.threading.eventwaithandle", "Method[reset].ReturnValue"]
    - ["system.uint16", "system.threading.thread!", "Method[volatileread].ReturnValue"]
    - ["system.intptr", "system.threading.nativeoverlapped", "Member[internallow]"]
    - ["system.int32", "system.threading.asyncflowcontrol", "Method[gethashcode].ReturnValue"]
    - ["system.boolean", "system.threading.cancellationtoken!", "Method[op_inequality].ReturnValue"]
    - ["system.boolean", "system.threading.readerwriterlock", "Method[anywriterssince].ReturnValue"]
    - ["system.boolean", "system.threading.cancellationtokenregistration", "Method[unregister].ReturnValue"]
    - ["t", "system.threading.asynclocalvaluechangedargs", "Member[previousvalue]"]
    - ["system.int32", "system.threading.spinwait", "Member[count]"]
    - ["system.int32", "system.threading.threadpool!", "Member[threadcount]"]
    - ["system.threading.threadstate", "system.threading.threadstate!", "Member[unstarted]"]
    - ["system.int32", "system.threading.interlocked!", "Method[exchange].ReturnValue"]
    - ["system.iasyncresult", "system.threading.overlapped", "Member[asyncresult]"]
    - ["system.boolean", "system.threading.cancellationtoken", "Member[iscancellationrequested]"]
    - ["system.single", "system.threading.volatile!", "Method[read].ReturnValue"]
    - ["system.threading.registeredwaithandle", "system.threading.threadpool!", "Method[registerwaitforsingleobject].ReturnValue"]
    - ["system.threading.eventwaithandle", "system.threading.eventwaithandleacl!", "Method[create].ReturnValue"]
    - ["system.boolean", "system.threading.asyncflowcontrol!", "Method[op_equality].ReturnValue"]
    - ["system.boolean", "system.threading.waithandle!", "Method[waitall].ReturnValue"]
    - ["system.uint32", "system.threading.interlocked!", "Method[increment].ReturnValue"]
    - ["system.globalization.cultureinfo", "system.threading.thread", "Member[currentculture]"]
    - ["system.int64", "system.threading.interlocked!", "Method[compareexchange].ReturnValue"]
    - ["system.threading.lockrecursionpolicy", "system.threading.readerwriterlockslim", "Member[recursionpolicy]"]
    - ["system.threading.tasks.valuetask", "system.threading.timer", "Method[disposeasync].ReturnValue"]
    - ["system.threading.cancellationtoken", "system.threading.cancellationtokenregistration", "Member[token]"]
    - ["system.threading.tasks.task", "system.threading.semaphoreslim", "Method[waitasync].ReturnValue"]
    - ["system.threading.threadpriority", "system.threading.threadpriority!", "Member[belownormal]"]
    - ["system.int32", "system.threading.interlocked!", "Method[add].ReturnValue"]
    - ["system.boolean", "system.threading.manualresetevent", "Method[reset].ReturnValue"]
    - ["system.int64", "system.threading.threadpool!", "Member[pendingworkitemcount]"]
    - ["t", "system.threading.lazyinitializer!", "Method[ensureinitialized].ReturnValue"]
    - ["system.intptr", "system.threading.interlocked!", "Method[exchange].ReturnValue"]
    - ["system.threading.apartmentstate", "system.threading.thread", "Method[getapartmentstate].ReturnValue"]
    - ["system.boolean", "system.threading.thread", "Member[isbackground]"]
    - ["system.uint64", "system.threading.interlocked!", "Method[compareexchange].ReturnValue"]
    - ["system.threading.tasks.valuetask", "system.threading.cancellationtokenregistration", "Method[disposeasync].ReturnValue"]
    - ["system.int64", "system.threading.thread!", "Method[volatileread].ReturnValue"]
    - ["system.boolean", "system.threading.asyncflowcontrol", "Method[equals].ReturnValue"]
    - ["system.uint64", "system.threading.interlocked!", "Method[increment].ReturnValue"]
    - ["system.threading.thread", "system.threading.thread!", "Member[currentthread]"]
    - ["system.int64", "system.threading.interlocked!", "Method[exchange].ReturnValue"]
    - ["system.threading.cancellationtokenregistration", "system.threading.cancellationtoken", "Method[unsaferegister].ReturnValue"]
    - ["system.threading.threadpriority", "system.threading.threadpriority!", "Member[normal]"]
    - ["system.object", "system.threading.threadpoolboundhandle!", "Method[getnativeoverlappedstate].ReturnValue"]
    - ["t", "system.threading.asynclocal", "Member[value]"]
    - ["system.boolean", "system.threading.lock", "Method[tryenter].ReturnValue"]
    - ["system.boolean", "system.threading.lockcookie!", "Method[op_inequality].ReturnValue"]
    - ["system.threading.nativeoverlapped*", "system.threading.overlapped", "Method[pack].ReturnValue"]
    - ["system.boolean", "system.threading.readerwriterlockslim", "Member[iswritelockheld]"]
    - ["system.int64", "system.threading.interlocked!", "Method[decrement].ReturnValue"]
    - ["system.threading.threadstate", "system.threading.threadstate!", "Member[running]"]
    - ["t", "system.threading.interlocked!", "Method[exchange].ReturnValue"]
    - ["system.threading.apartmentstate", "system.threading.apartmentstate!", "Member[mta]"]
    - ["system.object", "system.threading.hostexecutioncontext", "Member[state]"]
    - ["system.threading.threadstate", "system.threading.threadstate!", "Member[background]"]
    - ["system.threading.executioncontext", "system.threading.executioncontext!", "Method[capture].ReturnValue"]
    - ["system.threading.compressedstack", "system.threading.compressedstack!", "Method[getcompressedstack].ReturnValue"]
    - ["system.int64", "system.threading.interlocked!", "Method[read].ReturnValue"]
    - ["system.boolean", "system.threading.autoresetevent", "Method[reset].ReturnValue"]
    - ["system.string", "system.threading.threadlocal", "Method[tostring].ReturnValue"]
    - ["system.int32", "system.threading.overlapped", "Member[eventhandle]"]
    - ["system.boolean", "system.threading.asynclocalvaluechangedargs", "Member[threadcontextchanged]"]
    - ["system.uintptr", "system.threading.volatile!", "Method[read].ReturnValue"]
    - ["system.int32", "system.threading.readerwriterlockslim", "Member[recursivewritecount]"]
    - ["system.boolean", "system.threading.spinlock", "Member[isthreadownertrackingenabled]"]
    - ["system.threading.executioncontext", "system.threading.thread", "Member[executioncontext]"]
    - ["system.int32", "system.threading.lockcookie", "Method[gethashcode].ReturnValue"]
    - ["system.int64", "system.threading.barrier", "Member[currentphasenumber]"]
    - ["system.intptr", "system.threading.volatile!", "Method[read].ReturnValue"]
    - ["system.int32", "system.threading.waithandle!", "Member[waittimeout]"]
    - ["system.int64", "system.threading.volatile!", "Method[read].ReturnValue"]
    - ["system.boolean", "system.threading.timer", "Method[dispose].ReturnValue"]
    - ["system.uint32", "system.threading.interlocked!", "Method[add].ReturnValue"]
    - ["system.threading.lockcookie", "system.threading.readerwriterlock", "Method[releaselock].ReturnValue"]
    - ["system.threading.lock+scope", "system.threading.lock", "Method[enterscope].ReturnValue"]
    - ["system.threading.compressedstack", "system.threading.compressedstack!", "Method[capture].ReturnValue"]
    - ["system.threading.threadpriority", "system.threading.thread", "Member[priority]"]
    - ["system.boolean", "system.threading.timer", "Method[change].ReturnValue"]
    - ["system.globalization.cultureinfo", "system.threading.thread", "Member[currentuiculture]"]
    - ["system.threading.nativeoverlapped*", "system.threading.overlapped", "Method[unsafepack].ReturnValue"]
    - ["system.boolean", "system.threading.eventwaithandle!", "Method[tryopenexisting].ReturnValue"]
    - ["system.threading.executioncontext", "system.threading.executioncontext", "Method[createcopy].ReturnValue"]
    - ["system.double", "system.threading.interlocked!", "Method[exchange].ReturnValue"]
    - ["system.intptr", "system.threading.waithandle", "Member[handle]"]
    - ["system.boolean", "system.threading.synchronizationcontext", "Method[iswaitnotificationrequired].ReturnValue"]
    - ["system.threading.cancellationtoken", "system.threading.cancellationtokensource", "Member[token]"]
    - ["system.security.principal.iprincipal", "system.threading.thread!", "Member[currentprincipal]"]
    - ["system.threading.hostexecutioncontext", "system.threading.hostexecutioncontext", "Method[createcopy].ReturnValue"]
    - ["system.boolean", "system.threading.readerwriterlockslim", "Method[tryenterupgradeablereadlock].ReturnValue"]
    - ["system.uint16", "system.threading.interlocked!", "Method[compareexchange].ReturnValue"]
    - ["system.int32", "system.threading.thread!", "Method[volatileread].ReturnValue"]
    - ["system.int64", "system.threading.interlocked!", "Method[and].ReturnValue"]
    - ["system.timespan", "system.threading.periodictimer", "Member[period]"]
    - ["system.threading.semaphore", "system.threading.semaphoreacl!", "Method[create].ReturnValue"]
    - ["system.boolean", "system.threading.threadpool!", "Method[setmaxthreads].ReturnValue"]
    - ["system.boolean", "system.threading.cancellationtoken!", "Method[op_equality].ReturnValue"]
    - ["system.boolean", "system.threading.semaphoreacl!", "Method[tryopenexisting].ReturnValue"]
    - ["system.object", "system.threading.hostexecutioncontextmanager", "Method[sethostexecutioncontext].ReturnValue"]
    - ["system.intptr", "system.threading.overlapped", "Member[eventhandleintptr]"]
    - ["system.int32", "system.threading.interlocked!", "Method[increment].ReturnValue"]
    - ["system.boolean", "system.threading.lock", "Member[isheldbycurrentthread]"]
    - ["system.uint64", "system.threading.interlocked!", "Method[and].ReturnValue"]
    - ["system.int32", "system.threading.thread!", "Method[getcurrentprocessorid].ReturnValue"]
    - ["system.threading.lockrecursionpolicy", "system.threading.lockrecursionpolicy!", "Member[supportsrecursion]"]
    - ["system.boolean", "system.threading.namedwaithandleoptions", "Member[currentuseronly]"]
